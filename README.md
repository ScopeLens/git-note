# git-note
git学习笔记

安装教程:[文章地址](https://blog.csdn.net/qq_45281589/article/details/134650456)

- [git-note](#git-note)
    - [git配置](#git配置)
    - [git基本理论](#git基本理论)
    - [仓库创建](#仓库创建)
      - [创建本地仓库](#创建本地仓库)
      - [拉取远端仓库](#拉取远端仓库)
    - [基本操作](#基本操作)
      - [基础的工作流程](#基础的工作流程)
      - [GIT上传规范](#git上传规范)
      - [回退提交](#回退提交)
        - [版本回滚:覆盖历史:删除记录](#版本回滚覆盖历史删除记录)
        - [版本回滚:安全回滚:保留历史](#版本回滚安全回滚保留历史)
        - [本地文件回滚](#本地文件回滚)
          - [移出版本控制](#移出版本控制)
    - [分支管理](#分支管理)
      - [创建与合并分支](#创建与合并分支)
        - [创建分支](#创建分支)
        - [切换分支](#切换分支)
        - [推送新分支(远程仓库不存在)](#推送新分支远程仓库不存在)
        - [合并分支](#合并分支)
          - [快进合并](#快进合并)
          - [三方合并](#三方合并)
      - [删除分支](#删除分支)
        - [删除本地分支](#删除本地分支)
        - [删除远程分支](#删除远程分支)
      - [暂存开发记录](#暂存开发记录)
    - [变基](#变基)
      - [使用场景](#使用场景)
      - [操作流程](#操作流程)
    - [交互式变基](#交互式变基)

### git配置

系统配置:git config -l:查看git的配置

用户配置:git config --global --list

### git基本理论

>工作区域
四个工作区
1. Working Directory 工作目录
2. Stage(index) 暂存区
3. Repository 本地仓库 HEAD 指向主分支
4. Remote Directory 远端仓库

从上到下命令  *git add -> git commit ->git push*  
反过来 *git checkout <- git reset <- git pull*

git管理的文件存在三种状态:modified(已修改),staged(已暂存),committed(已提交)  


### 仓库创建

#### 创建本地仓库
git init  
语法:`git init [目录]`  
作用:如果不加目录参数就会直接将当前目录下初始成一个仓库,创建.git文件,加了之后就会在特定目录下创建

同步远端仓库
1. 远端仓库例如github,构建一个新的远端仓库,注意仓库中不需要存在任何文件,防止与本地文件存在冲突  
2. 使用`git remote add`命令,将远端仓库的url命名为`origin`(约定名称)
3. 添加完毕之后通过`git remote -v`来验证是否添加成功(添加错误可以使用`git remote rm [name]`移除)
4. 之后通过`git push`命令同步仓库文件  
   本地仓库分支会影响这个提交命令:`git push -u origin [本地分支:master/main]`  
   `-u`是为了设置本地分支跟踪远程的同名分支

#### 拉取远端仓库

git clone  
语法:`git clone [远程仓库地址URL]`  
作用:将远端仓库拉取到本地,直接在指令工作目录中创建新的仓库

### 基本操作

#### 基础的工作流程
1. `git pull`拉取最新的代码
2. 工作完毕之后使用`git status`查看暂存区有哪些文件发生了修改,新增
3. 使用`git add`添加文件到本次想要commit的内容中
4. `git commit`直接提交,不过一般会带上`-m [提交信息]`,提交到本地仓库
5. 确认完毕之后`git push`到远程仓库

#### GIT上传规范

|commit message|描述|
|--------------|----|
|init|初始化项目|
|feat|新功能|
|fix|bug修复|
|docs|文档变更|
|style|代码风格变化(不影响逻辑),格式变化,清理多余代码|
|refactor|代码重构|
|perf|性能优化|
|test|添加或修改功能测试|
|chore|杂项，构建工具或者辅助工具变化|
|build|构建系统或者外部依赖项变化|
|ci|配置文件变化或者脚本修改|
|revert|代码回滚|

#### 回退提交

##### 版本回滚:覆盖历史:删除记录

git reset  
语法:`git reset [选项] [目标版本/commit_id]`  
作用:回滚到对应版本  
选项:  
`--hard`:表示回滚到目标版本已提交的状态,会彻底丢弃所有修改  
`--soft`:表示回滚到目标版本的未提交状态  
`--mixed`:表示回滚到目标版本未添加状态,会保留目录文件,但是清空暂存区

git log  
语法:`git log`  
作用:查看当前分支的commit记录


git reflog  
语法:`git reflog`  
作用:查看历史记录,是所有的记录,相当于是后悔药,防止你回滚了但是又后悔了,可以查看历史所有的commit的id

在git中用`HEAD`表示当前版本,上个版本是`HEAD^`,上上个版本就是`HEAD^^`,更多就难写了,用`HEAD~N`,N表示前多少个版本  

回滚代码使用`git reset`,例如我要回滚到上一个版本`git reset --hard HEAD^`

##### 版本回滚:安全回滚:保留历史

git revert  
语法:`git revert [commit-hash]`  
作用:回滚本地提交,但是会在git树上构建新的提交,这个提交的作用是撤销之前的更改

##### 本地文件回滚

git restore  
语法:`git restore [选项] [文件地址]`  
作用:会将指定文件回滚到上一次提交或者暂存的状态,就是回滚到上一次追踪到的记录  
选项:  
`--staged`:将目标文件从暂存区回滚到工作区  
实例:`git restore .`丢弃当前目录下所有未暂存的文件修改

###### 移出版本控制

git rm  
语法:`git rm [选项] [目标文件]`  
作用:删除文件,或者放弃追踪文件  
选项:  
`--cached`:将文件移出版本控制,但是保留本地文件,如果不加这个选项实际就是执行了`rm`+`git add`

### 分支管理

#### 创建与合并分支

##### 创建分支

git branch  
语法:`git branch [选项] [分支名]`  
作用:创建新的分支,但是不会自动切换分支,如果不加新的分支名字就可以查看本地的所有分支

##### 切换分支

git switch  
语法:`git switch [选项] [分支名]`  
作用:切换到目标分支  
选项:  
`-c`:创建分支并切换

##### 推送新分支(远程仓库不存在)

当我在本地创建一个新的分支`feature`  
我第一次推送到远程仓库的时候(远程仓库中没有该分支),我必须使用`git push -u origin feature`命令去创建和关联该分支

##### 合并分支

合并分支的时候你需要先切换到目标分支,例如你要合并到主分支,那么就得先switch到main上

1. `git switch [目标分支]`
2. `git merge [工作分支]`

###### 快进合并

当目标分支中没有新的提交且是工作分支的直接祖先,就会直接合并,结果就是历史记录是一条直线,不会产生新的提交

原理:这种情况下,git不会真正创建一个新的分支,只是简单的**将目标分支的指针向前移动**,直接指向工作分支的最新提交记录

如果需要,也可以保留分支的边界信息,即在git树上还是能看到其他分支最后merge上来  
使用这个指令:`git merge --no-ff [分支名]`

###### 三方合并

当两边分支都存在新的提交,就会自动尝试将更改整合到一起,这会产生两个父提交

**合并冲突**

当两个分支对同一个文件的修改出现差异,那么就会出现冲突,git不清楚该采纳那一边的提交

处理步骤:  
1. 识别冲突:git会暂停合并过程,并且在命令行中提示冲突
   ```
   Auto-merging [fileName]
   CONFLICT (content):Merge conflict in [fileName]
   ```
2. 手动解决  
   需要打开冲突的文件,能看到git对于冲突的部分进行了标注,需要手动解决  
   解决完毕之后,删除掉标注的符号`<<<<<<<`,`=======`,`>>>>>>>`
3. 暂存已解决的文件
   `git add [fileName]` 相当于告诉git处理好了这个文件
4. 完成合并
   `git commit`/`git merge --continue`

#### 删除分支

##### 删除本地分支

使用`git branch`的选项即可  
`git branch -d [分支名]`  `-d`是`--delete`的缩写,安全删除,只有当目标分支的更改都被合并到当前分支的时候才能允许删除

`git branch -D [分支名]` `-D`是`--delete --force`的缩写,会强制删除分支

使用之前都必须切换到其他分支上

##### 删除远程分支

使用`git push`命令  
1. `git push origin --delete [分支名]`  
2. `git push origin :[分支名]`  
这两种方式都会删除远端分支,但是不会删除本地分支

#### 暂存开发记录

因为你切换分支的时候工作区必须是干净的,但是现在必须切换分支去修复bug,但是当前的工作区任务又没有完成,那该怎么办.

git stash  
语法:`git stash`  
作用:将当前的工作区内容缓存起来,未来切换会本分支还能恢复

当修复bug完毕,回到工作分支的时候,就可以使用`git stash list`查看暂存

可以通过两种方式去恢复工作区

1. `git stash apply`,恢复后`git stash list`的那个stash不会删除,必须使用`git stash drop`去删除
2. `git stash pop`,恢复工作区的同时删除stash

因为git stash是本地仓库所有分支共享的,所以可以在不同分支上`apply`去同步工作区来共享工作成果

不过对于需要同时修复两个分支上的问题,但是两个分支又不能同步代码的情况,git有另一个指令去更好的处理这这个问题

git cherry-pick  
语法:`git cherry-pick [commit-hash]`  
作用:将某个commit同步提交到当前分支

### 变基

#### 使用场景
简单来说就是当远程分支领先本地分支,但是本地又存在没有提交的分支,那么你可以选择使用`merge`指令进行合并  
但是这样会让git tree中出现分支,影响美观.如果想要保持一条直线,就可以使用变基,原理就是先将远程的提交同步到本地,然后**将本地没未提交的记录变更祖先提交到最新的提交**,这样看起来git tree就是一条直线

#### 操作流程

1. `git fetch [分支名]`下载最新的提交和分支引用
2. `git rebase [分支名]`将当前的分支基于远程最新的提交进行变基
3. `git push origin [分支名] --force-with-leave`推送代码

操作过程中可能会出现冲突,那就按照之前的逻辑解决就行

这上面的也可以简化为一条指令`git pull --rebase`

### 交互式变基

这种功能是用来整理git tree的,可以针对git tree的每一个节点来做处理

使用`git rebase -i [起始节点]`,之后git会打开一个文本编辑器

| 指令 | 完整指令 | 作用                                                    |
| ---- | -------- | ------------------------------------------------------- |
| p    | pick     | 默认操作                                                |
| r    | reword   | 修改提交信息                                            |
| e    | edit     | 暂停变基,可以对该commit的代码进行修改,拆分,修复         |
| s    | squash   | 合并到前一个提交中,要求你重新编辑一个新的commit message |
| f    | fixup    | 合并到前一个提交,沿用前一个提交的message                |
| d    | drop     | 丢弃该提交                                              |